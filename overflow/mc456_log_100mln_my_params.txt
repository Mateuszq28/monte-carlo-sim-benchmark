time elapsed: 13290.7210 seconds

=================================

sim results:

number of photons = 100000000
bin size = 0.00833 [cm] 
last row is overflow. Ignore.
r [cm] 	 Fsph [1/cm2] 	 Fcyl [1/cm2] 	 Fpla [1/cm2]
0.00417 	 1.565e-02 	 1.620e-01 	 2.696e-01 
0.01250 	 1.150e-02 	 1.611e-01 	 2.696e-01 
0.02083 	 1.128e-02 	 1.609e-01 	 2.697e-01 
0.02917 	 1.159e-02 	 1.615e-01 	 2.699e-01 
0.03750 	 1.135e-02 	 1.611e-01 	 2.701e-01 
0.04583 	 1.138e-02 	 1.613e-01 	 2.704e-01 
0.05417 	 1.135e-02 	 1.616e-01 	 2.708e-01 
0.06250 	 1.123e-02 	 1.617e-01 	 2.711e-01 
0.07083 	 1.137e-02 	 1.617e-01 	 2.714e-01 
0.07917 	 1.133e-02 	 1.618e-01 	 2.720e-01 
0.08750 	 1.128e-02 	 1.618e-01 	 2.726e-01 
0.09583 	 1.127e-02 	 1.622e-01 	 2.731e-01 
0.10417 	 1.130e-02 	 1.622e-01 	 2.738e-01 
0.11250 	 1.139e-02 	 1.625e-01 	 2.745e-01 
0.12083 	 1.135e-02 	 1.628e-01 	 2.753e-01 
0.12917 	 1.134e-02 	 1.630e-01 	 2.761e-01 
0.13750 	 1.143e-02 	 1.631e-01 	 2.770e-01 
0.14583 	 1.140e-02 	 1.636e-01 	 2.779e-01 
0.15417 	 1.142e-02 	 1.638e-01 	 2.788e-01 
0.16250 	 1.137e-02 	 1.641e-01 	 2.800e-01 
0.17083 	 1.140e-02 	 1.645e-01 	 2.810e-01 
0.17917 	 1.148e-02 	 1.648e-01 	 2.822e-01 
0.18750 	 1.149e-02 	 1.651e-01 	 2.833e-01 
0.19583 	 1.145e-02 	 1.655e-01 	 2.847e-01 
0.20417 	 1.147e-02 	 1.659e-01 	 2.859e-01 
0.21250 	 1.149e-02 	 1.663e-01 	 2.873e-01 
0.22083 	 1.155e-02 	 1.668e-01 	 2.887e-01 
0.22917 	 1.155e-02 	 1.672e-01 	 2.903e-01 
0.23750 	 1.159e-02 	 1.677e-01 	 2.916e-01 
0.24583 	 1.159e-02 	 1.681e-01 	 2.933e-01 
0.25417 	 1.160e-02 	 1.687e-01 	 2.952e-01 
0.26250 	 1.163e-02 	 1.692e-01 	 2.967e-01 
0.27083 	 1.167e-02 	 1.698e-01 	 2.985e-01 
0.27917 	 1.169e-02 	 1.704e-01 	 3.004e-01 
0.28750 	 1.173e-02 	 1.710e-01 	 3.024e-01 
0.29583 	 1.174e-02 	 1.716e-01 	 3.043e-01 
0.30417 	 1.178e-02 	 1.721e-01 	 3.063e-01 
0.31250 	 1.179e-02 	 1.728e-01 	 3.083e-01 
0.32083 	 1.186e-02 	 1.735e-01 	 3.104e-01 
0.32917 	 1.186e-02 	 1.741e-01 	 3.128e-01 
0.33750 	 1.188e-02 	 1.748e-01 	 3.149e-01 
0.34583 	 1.190e-02 	 1.755e-01 	 3.174e-01 
0.35417 	 1.195e-02 	 1.763e-01 	 3.197e-01 
0.36250 	 1.197e-02 	 1.770e-01 	 3.223e-01 
0.37083 	 1.201e-02 	 1.779e-01 	 3.247e-01 
0.37917 	 1.203e-02 	 1.787e-01 	 3.274e-01 
0.38750 	 1.209e-02 	 1.794e-01 	 3.300e-01 
0.39583 	 1.211e-02 	 1.802e-01 	 3.327e-01 
0.40417 	 1.213e-02 	 1.812e-01 	 3.356e-01 
0.41250 	 1.219e-02 	 1.820e-01 	 3.385e-01 
0.42083 	 1.220e-02 	 1.828e-01 	 3.413e-01 
0.42917 	 1.226e-02 	 1.838e-01 	 3.444e-01 
0.43750 	 1.229e-02 	 1.847e-01 	 3.475e-01 
0.44583 	 1.235e-02 	 1.857e-01 	 3.506e-01 
0.45417 	 1.238e-02 	 1.867e-01 	 3.539e-01 
0.46250 	 1.242e-02 	 1.877e-01 	 3.569e-01 
0.47083 	 1.247e-02 	 1.886e-01 	 3.605e-01 
0.47917 	 1.253e-02 	 1.898e-01 	 3.638e-01 
0.48750 	 1.256e-02 	 1.908e-01 	 3.675e-01 
0.49583 	 1.261e-02 	 1.919e-01 	 3.710e-01 
0.50417 	 1.267e-02 	 1.930e-01 	 3.746e-01 
0.51250 	 1.271e-02 	 1.942e-01 	 3.782e-01 
0.52083 	 1.278e-02 	 1.954e-01 	 3.819e-01 
0.52917 	 1.281e-02 	 1.966e-01 	 3.859e-01 
0.53750 	 1.288e-02 	 1.978e-01 	 3.899e-01 
0.54583 	 1.291e-02 	 1.991e-01 	 3.939e-01 
0.55417 	 1.295e-02 	 2.002e-01 	 3.979e-01 
0.56250 	 1.303e-02 	 2.016e-01 	 4.023e-01 
0.57083 	 1.307e-02 	 2.030e-01 	 4.066e-01 
0.57917 	 1.312e-02 	 2.044e-01 	 4.107e-01 
0.58750 	 1.320e-02 	 2.057e-01 	 4.151e-01 
0.59583 	 1.325e-02 	 2.072e-01 	 4.197e-01 
0.60417 	 1.332e-02 	 2.086e-01 	 4.244e-01 
0.61250 	 1.337e-02 	 2.102e-01 	 4.290e-01 
0.62083 	 1.344e-02 	 2.116e-01 	 4.338e-01 
0.62917 	 1.351e-02 	 2.132e-01 	 4.385e-01 
0.63750 	 1.356e-02 	 2.148e-01 	 4.436e-01 
0.64583 	 1.363e-02 	 2.165e-01 	 4.487e-01 
0.65417 	 1.371e-02 	 2.181e-01 	 4.539e-01 
0.66250 	 1.376e-02 	 2.198e-01 	 4.591e-01 
0.67083 	 1.383e-02 	 2.216e-01 	 4.644e-01 
0.67917 	 1.390e-02 	 2.234e-01 	 4.699e-01 
0.68750 	 1.397e-02 	 2.252e-01 	 4.752e-01 
0.69583 	 1.405e-02 	 2.271e-01 	 4.809e-01 
0.70417 	 1.412e-02 	 2.290e-01 	 4.865e-01 
0.71250 	 1.419e-02 	 2.310e-01 	 4.921e-01 
0.72083 	 1.426e-02 	 2.330e-01 	 4.980e-01 
0.72917 	 1.434e-02 	 2.352e-01 	 5.042e-01 
0.73750 	 1.441e-02 	 2.374e-01 	 5.102e-01 
0.74583 	 1.449e-02 	 2.395e-01 	 5.164e-01 
0.75417 	 1.456e-02 	 2.418e-01 	 5.229e-01 
0.76250 	 1.465e-02 	 2.443e-01 	 5.291e-01 
0.77083 	 1.473e-02 	 2.467e-01 	 5.357e-01 
0.77917 	 1.483e-02 	 2.491e-01 	 5.421e-01 
0.78750 	 1.490e-02 	 2.518e-01 	 5.490e-01 
0.79583 	 1.498e-02 	 2.544e-01 	 5.557e-01 
0.80417 	 1.508e-02 	 2.573e-01 	 5.629e-01 
0.81250 	 1.516e-02 	 2.602e-01 	 5.698e-01 
0.82083 	 1.525e-02 	 2.633e-01 	 5.769e-01 
0.82917 	 1.534e-02 	 2.664e-01 	 5.842e-01 
0.83750 	 1.544e-02 	 2.697e-01 	 5.915e-01 
0.84583 	 1.552e-02 	 2.731e-01 	 5.987e-01 
0.85417 	 1.561e-02 	 2.768e-01 	 6.063e-01 
0.86250 	 1.570e-02 	 2.807e-01 	 6.143e-01 
0.87083 	 1.580e-02 	 2.847e-01 	 6.221e-01 
0.87917 	 1.590e-02 	 2.889e-01 	 6.302e-01 
0.88750 	 1.599e-02 	 2.934e-01 	 6.385e-01 
0.89583 	 1.608e-02 	 2.981e-01 	 6.464e-01 
0.90417 	 1.619e-02 	 3.033e-01 	 6.548e-01 
0.91250 	 1.629e-02 	 3.088e-01 	 6.632e-01 
0.92083 	 1.640e-02 	 3.147e-01 	 6.717e-01 
0.92917 	 1.650e-02 	 3.212e-01 	 6.808e-01 
0.93750 	 1.661e-02 	 3.281e-01 	 6.894e-01 
0.94583 	 1.672e-02 	 3.360e-01 	 6.987e-01 
0.95417 	 1.682e-02 	 3.446e-01 	 7.077e-01 
0.96250 	 1.694e-02 	 3.543e-01 	 7.169e-01 
0.97083 	 1.705e-02 	 3.654e-01 	 7.267e-01 
0.97917 	 1.716e-02 	 3.780e-01 	 7.362e-01 
0.98750 	 1.728e-02 	 3.930e-01 	 7.462e-01 
0.99583 	 1.740e-02 	 4.110e-01 	 7.560e-01 
1.00417 	 1.752e-02 	 4.334e-01 	 7.660e-01 
1.01250 	 1.764e-02 	 4.625e-01 	 7.761e-01 
1.02083 	 1.775e-02 	 5.028e-01 	 7.862e-01 
1.02917 	 1.787e-02 	 5.648e-01 	 7.966e-01 
1.03750 	 1.801e-02 	 6.840e-01 	 8.076e-01 
1.04583 	 1.812e-02 	 1.987e+00 	 8.183e-01 
1.05417 	 1.825e-02 	 9.257e-01 	 8.291e-01 
1.06250 	 1.838e-02 	 6.327e-01 	 8.402e-01 
1.07083 	 1.852e-02 	 5.330e-01 	 8.518e-01 
1.07917 	 1.865e-02 	 4.758e-01 	 8.631e-01 
1.08750 	 1.879e-02 	 4.366e-01 	 8.749e-01 
1.09583 	 1.893e-02 	 4.071e-01 	 8.863e-01 
1.10417 	 1.907e-02 	 3.839e-01 	 8.984e-01 
1.11250 	 1.920e-02 	 3.646e-01 	 9.107e-01 
1.12083 	 1.935e-02 	 3.483e-01 	 9.230e-01 
1.12917 	 1.949e-02 	 3.341e-01 	 9.355e-01 
1.13750 	 1.964e-02 	 3.215e-01 	 9.481e-01 
1.14583 	 1.978e-02 	 3.102e-01 	 9.608e-01 
1.15417 	 1.993e-02 	 3.000e-01 	 9.737e-01 
1.16250 	 2.009e-02 	 2.907e-01 	 9.871e-01 
1.17083 	 2.023e-02 	 2.822e-01 	 1.001e+00 
1.17917 	 2.038e-02 	 2.742e-01 	 1.014e+00 
1.18750 	 2.054e-02 	 2.667e-01 	 1.028e+00 
1.19583 	 2.070e-02 	 2.597e-01 	 1.042e+00 
1.20417 	 2.085e-02 	 2.532e-01 	 1.056e+00 
1.21250 	 2.103e-02 	 2.469e-01 	 1.070e+00 
1.22083 	 2.118e-02 	 2.410e-01 	 1.084e+00 
1.22917 	 2.134e-02 	 2.355e-01 	 1.099e+00 
1.23750 	 2.152e-02 	 2.301e-01 	 1.114e+00 
1.24583 	 2.168e-02 	 2.250e-01 	 1.129e+00 
1.25417 	 2.186e-02 	 2.201e-01 	 1.144e+00 
1.26250 	 2.203e-02 	 2.154e-01 	 1.160e+00 
1.27083 	 2.220e-02 	 2.108e-01 	 1.175e+00 
1.27917 	 2.238e-02 	 2.065e-01 	 1.192e+00 
1.28750 	 2.257e-02 	 2.023e-01 	 1.207e+00 
1.29583 	 2.274e-02 	 1.981e-01 	 1.224e+00 
1.30417 	 2.292e-02 	 1.942e-01 	 1.240e+00 
1.31250 	 2.311e-02 	 1.904e-01 	 1.257e+00 
1.32083 	 2.330e-02 	 1.867e-01 	 1.274e+00 
1.32917 	 2.350e-02 	 1.831e-01 	 1.291e+00 
1.33750 	 2.368e-02 	 1.796e-01 	 1.309e+00 
1.34583 	 2.389e-02 	 1.762e-01 	 1.326e+00 
1.35417 	 2.408e-02 	 1.729e-01 	 1.343e+00 
1.36250 	 2.430e-02 	 1.697e-01 	 1.361e+00 
1.37083 	 2.449e-02 	 1.666e-01 	 1.379e+00 
1.37917 	 2.469e-02 	 1.635e-01 	 1.398e+00 
1.38750 	 2.490e-02 	 1.605e-01 	 1.416e+00 
1.39583 	 2.511e-02 	 1.575e-01 	 1.435e+00 
1.40417 	 2.532e-02 	 1.548e-01 	 1.454e+00 
1.41250 	 2.554e-02 	 1.520e-01 	 1.474e+00 
1.42083 	 2.575e-02 	 1.493e-01 	 1.493e+00 
1.42917 	 2.597e-02 	 1.467e-01 	 1.512e+00 
1.43750 	 2.619e-02 	 1.440e-01 	 1.532e+00 
1.44583 	 2.642e-02 	 1.415e-01 	 1.552e+00 
1.45417 	 2.664e-02 	 1.390e-01 	 1.572e+00 
1.46250 	 2.688e-02 	 1.366e-01 	 1.593e+00 
1.47083 	 2.711e-02 	 1.342e-01 	 1.613e+00 
1.47917 	 2.735e-02 	 1.319e-01 	 1.634e+00 
1.48750 	 2.758e-02 	 1.296e-01 	 1.655e+00 
1.49583 	 2.783e-02 	 1.274e-01 	 1.676e+00 
1.50417 	 2.807e-02 	 1.252e-01 	 1.697e+00 
1.51250 	 2.831e-02 	 1.230e-01 	 1.718e+00 
1.52083 	 2.856e-02 	 1.209e-01 	 1.739e+00 
1.52917 	 2.881e-02 	 1.188e-01 	 1.761e+00 
1.53750 	 2.906e-02 	 1.168e-01 	 1.782e+00 
1.54583 	 2.931e-02 	 1.148e-01 	 1.805e+00 
1.55417 	 2.958e-02 	 1.129e-01 	 1.826e+00 
1.56250 	 2.984e-02 	 1.110e-01 	 1.848e+00 
1.57083 	 3.011e-02 	 1.091e-01 	 1.870e+00 
1.57917 	 3.038e-02 	 1.072e-01 	 1.892e+00 
1.58750 	 3.065e-02 	 1.055e-01 	 1.914e+00 
1.59583 	 3.092e-02 	 1.037e-01 	 1.935e+00 
1.60417 	 3.120e-02 	 1.019e-01 	 1.957e+00 
1.61250 	 3.148e-02 	 1.002e-01 	 1.979e+00 
1.62083 	 3.176e-02 	 9.856e-02 	 2.001e+00 
1.62917 	 3.205e-02 	 9.692e-02 	 2.023e+00 
1.63750 	 3.235e-02 	 9.531e-02 	 2.045e+00 
1.64583 	 3.264e-02 	 9.371e-02 	 2.066e+00 
1.65417 	 3.294e-02 	 9.212e-02 	 2.087e+00 
1.66250 	 3.324e-02 	 9.059e-02 	 2.109e+00 
1.67083 	 3.354e-02 	 8.910e-02 	 2.130e+00 
1.67917 	 3.385e-02 	 8.762e-02 	 2.151e+00 
1.68750 	 3.416e-02 	 8.619e-02 	 2.171e+00 
1.69583 	 3.447e-02 	 8.480e-02 	 2.191e+00 
1.70417 	 3.479e-02 	 8.337e-02 	 2.211e+00 
1.71250 	 3.511e-02 	 8.199e-02 	 2.230e+00 
1.72083 	 3.543e-02 	 8.067e-02 	 2.249e+00 
1.72917 	 3.575e-02 	 7.932e-02 	 2.267e+00 
1.73750 	 3.608e-02 	 7.804e-02 	 2.285e+00 
1.74583 	 3.642e-02 	 7.677e-02 	 2.302e+00 
1.75417 	 3.675e-02 	 7.548e-02 	 2.319e+00 
1.76250 	 3.708e-02 	 7.424e-02 	 2.335e+00 
1.77083 	 3.742e-02 	 7.303e-02 	 2.350e+00 
1.77917 	 3.776e-02 	 7.184e-02 	 2.364e+00 
1.78750 	 3.811e-02 	 7.068e-02 	 2.377e+00 
1.79583 	 3.847e-02 	 6.952e-02 	 2.389e+00 
1.80417 	 3.881e-02 	 6.838e-02 	 2.401e+00 
1.81250 	 3.916e-02 	 6.724e-02 	 2.410e+00 
1.82083 	 3.949e-02 	 6.617e-02 	 2.420e+00 
1.82917 	 3.986e-02 	 6.511e-02 	 2.427e+00 
1.83750 	 4.022e-02 	 6.403e-02 	 2.433e+00 
1.84583 	 4.058e-02 	 6.300e-02 	 2.439e+00 
1.85417 	 4.094e-02 	 6.199e-02 	 2.442e+00 
1.86250 	 4.130e-02 	 6.098e-02 	 2.444e+00 
1.87083 	 4.167e-02 	 5.999e-02 	 2.445e+00 
1.87917 	 4.203e-02 	 5.903e-02 	 2.444e+00 
1.88750 	 4.239e-02 	 5.809e-02 	 2.441e+00 
1.89583 	 4.277e-02 	 5.713e-02 	 2.435e+00 
1.90417 	 4.313e-02 	 5.621e-02 	 2.428e+00 
1.91250 	 4.348e-02 	 5.531e-02 	 2.418e+00 
1.92083 	 4.384e-02 	 5.441e-02 	 2.407e+00 
1.92917 	 4.420e-02 	 5.353e-02 	 2.393e+00 
1.93750 	 4.455e-02 	 5.267e-02 	 2.377e+00 
1.94583 	 4.490e-02 	 5.182e-02 	 2.358e+00 
1.95417 	 4.525e-02 	 5.098e-02 	 2.335e+00 
1.96250 	 4.559e-02 	 5.017e-02 	 2.310e+00 
1.97083 	 4.593e-02 	 4.937e-02 	 2.281e+00 
1.97917 	 4.626e-02 	 4.858e-02 	 2.248e+00 
1.98750 	 4.659e-02 	 4.779e-02 	 2.207e+00 
1.99583 	 4.690e-02 	 4.704e-02 	 1.157e+00 
2.00417 	 3.995e+00 	 3.741e+00 	 7.359e+01 


=================================

code that generated this simulation:


/********************************************
 *  mc321.c    , in ANSI Standard C programing language
 *
 *  Monte Carlo simulation yielding spherical, cylindrical, and planar 
 *    responses to an isotropic point source in an infinite homogeneous 
 *    medium with no boundaries. This program is a minimal Monte Carlo 
 *    program scoring photon distributions in spherical, cylindrical, 
 *    and planar shells.
 *
 *  by Steven L. Jacques based on prior collaborative work 
 *    with Lihong Wang, Scott Prahl, and Marleen Keijzer.
 *    partially funded by the NIH (R29-HL45045, 1991-1997) and  
 *    the DOE (DE-FG05-91ER617226, DE-FG03-95ER61971, 1991-1999).
 *
 *  A published report illustrates use of the program:
 *    S. L. Jacques: "Light distributions from point, line, and plane 
 *    sources for photochemical reactions and fluorescence in turbid 
 *    biological tissues," Photochem. Photobiol. 67:23-32, 1998. 
 *
 *  Trivial fixes to remove warnings SAP, 11/2017
 **********/

#include <math.h>
#include <stdio.h>
#include <stdbool.h>

// for Cube
#define MAX_XY 180
#define MAX_Z 240

#define	PI          3.1415926
#define	LIGHTSPEED	2.997925E10 /* in vacuo speed of light [cm/s] */
#define ALIVE       1   		/* if photon not yet terminated */
#define DEAD        0    		/* if photon is to be terminated */
#define THRESHOLD   1.0E-4		/* used in roulette */
#define CHANCE      0.1  		/* used in roulette */
#define COS90D      1.0E-6
     /* If cos(theta) <= COS90D, theta >= PI/2 - 1e-6 rad. */
#define ONE_MINUS_COSZERO 1.0E-12
     /* If 1-cos(theta) <= ONE_MINUS_COSZERO, fabs(theta) <= 1e-6 rad. */
     /* If 1+cos(theta) <= ONE_MINUS_COSZERO, fabs(PI-theta) <= 1e-6 rad. */
#define SIGN(x)           ((x)>=0 ? 1:-1)
#define InitRandomGen    (double) RandomGen(0, 1, NULL)
     /* Initializes the seed for the random number generator. */     
#define RandomNum        (double) RandomGen(1, 0, NULL)
     /* Calls for a random number from the randum number generator. */

/* DECLARE FUNCTION */
double RandomGen(char Type, long Seed, long *Status);  
     /* Random number generator */

void save_3d_array_to_json(const char* filename, double arr[MAX_XY][MAX_XY][MAX_Z], int x, int y, int z, long long Nphotons, double cube_overflow, double bins_per_1_cm);

void displayProgressBar(long long progress, long long total, long long min_step);


int main() {

/* Propagation parameters */
double	x, y, z;    /* photon position */
double	ux, uy, uz; /* photon trajectory as cosines */
double  uxx, uyy, uzz;	/* temporary values used during SPIN */
double	s;          /* step sizes. s = -log(RND)/mus [cm] */
double	costheta;   /* cos(theta) */
double  sintheta;   /* sin(theta) */
double	cospsi;     /* cos(psi) */
double  sinpsi;     /* sin(psi) */
double	psi;        /* azimuthal angle */
double	W;          /* photon weight */
double	absorb;     /* weighted deposited in a step due to absorption */
short   photon_status;  /* flag = ALIVE=1 or DEAD=0 */

/* other variables */
double	Csph[241];  /* spherical   photon concentration CC[ir=0..100] */
double	Ccyl[241];  /* cylindrical photon concentration CC[ir=0..100] */
double	Cpla[241];  /* planar      photon concentration CC[ir=0..100] */

// to avoid stack overflow
// Correct allocation with malloc
double (*Cube)[MAX_XY][MAX_Z] = (double (*)[MAX_XY][MAX_Z])malloc(MAX_XY * MAX_XY * MAX_Z * sizeof(double));
if (Cube == NULL) {
    printf("Memory allocation failed.\n");
    return 1;
}

double cube_overflow;
double	Fsph;       /* fluence in spherical shell */
double	Fcyl;       /* fluence in cylindrical shell */
double	Fpla;       /* fluence in planar shell */
double	mua;        /* absorption coefficient [cm^-1] */
double	mus;        /* scattering coefficient [cm^-1] */
double	g;          /* anisotropy [-] */
double	albedo;     /* albedo of tissue */
double	nt;         /* tissue index of refraction */
long long	Nphotons;   /* number of photons in simulation */
long long min_step_progress_bar;
short	NR_z;         /* number of z positions */
short	NR_xy;         /* number of xy positions */
double	z_size;  /* maximum z size of cube */
double	xy_size;  /* maximum xy size of cube */
double	r;          /* radial position */
double  dr;         /* radial bin size */
short	ir;         /* index to radial position */
short ix;
short iy;
short iz;
double x_start;
double y_start;
double z_start;
bool ix_is_in;
bool iy_is_in;
bool iz_is_in;
bool is_in;
double  shellvolume;  /* volume of shell at radial position r */

/* dummy variables */
double  rnd;        /* assigned random value 0-1 */
double	temp;    /* dummy variables */
FILE*	target;     /* point to output file */


/**** INPUT
   Input the optical properties
   Input the bin and array sizes 
   Input the number of photons
*****/

mua         = 0.37;     /* cm^-1 */
mus         = 23.88889;  /* cm^-1 */
g           = 0.9;  
nt          = 1.36;
Nphotons    = 1e8; /* set number of photons in simulation */
min_step_progress_bar = Nphotons/100;
z_size = 2.0;   /* cm, total range over which bins extend */
xy_size = 1.5; // cm
NR_z          = 240;	 /* set number of bins.  */
NR_xy = 180;
   /* IF NR_z IS ALTERED, THEN USER MUST ALSO ALTER THE ARRAY DECLARATION TO A SIZE = NR_z + 1. */
dr          = z_size/NR_z;  /* cm */
albedo      = mus/(mus + mua);


/**** INITIALIZATIONS 
*****/
InitRandomGen;
printf("initializing arrays with zeros...\n");
for (ir=0; ir<=NR_z; ir++) {
  Csph[ir] = 0;
  Ccyl[ir] = 0;
  Cpla[ir] = 0;
}

// [x][y][z]
for (int ix=0; ix<NR_xy; ix++)
  for (int iy=0; iy<NR_xy; iy++)
    for (int iz=0; iz<NR_z; iz++)
      Cube[ix][iy][iz] = 0;
cube_overflow = 0;
printf("initializing done...\n");

// start pos
x_start = 89 * dr;
y_start = 89 * dr;
z_start = 239 * dr;


/**** RUN
   Launch N photons, initializing each one before progation.
*****/
printf("simulation progress:\n");
for (long long i_photon = 1; i_photon <= Nphotons; i_photon++)
{
displayProgressBar(i_photon, Nphotons, min_step_progress_bar);
  


/**** LAUNCH 
   Initialize photon position and trajectory.
   Implements a point source [0,0,-1].
*****/
W = 1.0;                    /* set photon weight to one */
photon_status = ALIVE;      /* Launch an ALIVE photon */

x = x_start;    /* Set photon position to origin. */
y = y_start;
z = z_start;

/* source - vartical down [0,0,-1] */
ux = 0;
uy = 0;
uz = -1;


/* HOP_DROP_SPIN_CHECK
   Propagate one photon until it dies as determined by ROULETTE.
*******/
do {


/**** HOP
   Take step to new position
   s = stepsize
   ux, uy, uz are cosines of current photon trajectory
*****/
  while ((rnd = RandomNum) <= 0.0);   /* yields 0 < rnd <= 1 */
  s = -log(rnd)/(mua + mus);          /* Step size.  Note: log() is base e */
  x += s * ux;                        /* Update positions. */
  y += s * uy;
  z += s * uz;


/**** DROP
   Drop photon weight (W) into local bin.
*****/
   absorb = W*(1 - albedo);      /* photon weight absorbed at this step */
   W -= absorb;                  /* decrement WEIGHT by amount absorbed */
   
   /* spherical */
   r = sqrt(x*x + y*y + z*z);    /* current spherical radial position */
   ir = (short)(r/dr);           /* ir = index to spatial bin */
   if (ir >= NR_z) ir = NR_z;        /* last bin is for overflow */
   Csph[ir] += absorb;           /* DROP absorbed weight into bin */
   
   /* cylindrical */
   r = sqrt(x*x + y*y);          /* current cylindrical radial position */
   ir = (short)(r/dr);           /* ir = index to spatial bin */
   if (ir >= NR_z) ir = NR_z;        /* last bin is for overflow */
   Ccyl[ir] += absorb;           /* DROP absorbed weight into bin */
   
   /* planar */
   r = fabs(z);                  /* current planar radial position */
   ir = (short)(r/dr);           /* ir = index to spatial bin */
   if (ir >= NR_z) ir = NR_z;        /* last bin is for overflow */
   Cpla[ir] += absorb;           /* DROP absorbed weight into bin */

  // --- cube ---
  ix = x/dr;
  iy = y/dr;
  iz = z/dr;
  ix_is_in = (0 <= ix && ix < NR_xy);
  iy_is_in = (0 <= iy && iy < NR_xy);
  iz_is_in = (0 <= iz && iz < NR_z);
  is_in = (ix_is_in && iy_is_in && iz_is_in);
  if (!is_in) cube_overflow += absorb;
  else Cube[ix][iy][iz] += absorb;

/**** SPIN 
   Scatter photon into new trajectory defined by theta and psi.
   Theta is specified by cos(theta), which is determined 
   based on the Henyey-Greenstein scattering function.
   Convert theta and psi into cosines ux, uy, uz. 
*****/
  /* Sample for costheta */
  rnd = RandomNum;
     if (g == 0.0)
        costheta = 2.0*rnd - 1.0;
     else {
        double temp = (1.0 - g*g)/(1.0 - g + 2*g*rnd);
        costheta = (1.0 + g*g - temp*temp)/(2.0*g);
        }
  sintheta = sqrt(1.0 - costheta*costheta); /* sqrt() is faster than sin(). */

  /* Sample psi. */
  psi = 2.0*PI*RandomNum;
  cospsi = cos(psi);
  if (psi < PI)
    sinpsi = sqrt(1.0 - cospsi*cospsi);     /* sqrt() is faster than sin(). */
  else
    sinpsi = -sqrt(1.0 - cospsi*cospsi);

  /* New trajectory. */
  if (1 - fabs(uz) <= ONE_MINUS_COSZERO) {      /* close to perpendicular. */
    uxx = sintheta * cospsi;
    uyy = sintheta * sinpsi;
    uzz = costheta * SIGN(uz);   /* SIGN() is faster than division. */
    } 
  else {					/* usually use this option */
    temp = sqrt(1.0 - uz * uz);
    uxx = sintheta * (ux * uz * cospsi - uy * sinpsi) / temp + ux * costheta;
    uyy = sintheta * (uy * uz * cospsi + ux * sinpsi) / temp + uy * costheta;
    uzz = -sintheta * cospsi * temp + uz * costheta;
    }
    
  /* Update trajectory */
  ux = uxx;
  uy = uyy;
  uz = uzz;


/**** CHECK ROULETTE 
   If photon weight below THRESHOLD, then terminate photon using Roulette technique.
   Photon has CHANCE probability of having its weight increased by factor of 1/CHANCE,
   and 1-CHANCE probability of terminating.
*****/
if (W < THRESHOLD) {
   if (RandomNum <= CHANCE)
      W /= CHANCE;
   else photon_status = DEAD;
   }


} /* end STEP_CHECK_HOP_SPIN */
while (photon_status == ALIVE);

  /* If photon dead, then launch new photon. */
} /* end RUN */


/**** SAVE
   Convert data to relative fluence rate [cm^-2] and save to file called "mcmin321.out".
*****/
// target = fopen("mc321.out", "w");
printf("saving data...\n");
target = fopen("mc456_out.txt", "w");

/* print header */
fprintf(target, "number of photons = %lld\n", Nphotons);
fprintf(target, "bin size = %5.5f [cm] \n", dr);
fprintf(target, "last row is overflow. Ignore.\n");

/* print column titles */
fprintf(target, "r [cm] \t Fsph [1/cm2] \t Fcyl [1/cm2] \t Fpla [1/cm2]\n");

/* print data:  radial position, fluence rates for 3D, 2D, 1D geometries */
for (ir=0; ir<=NR_z; ir++) {
  	/* r = sqrt(1.0/3 - (ir+1) + (ir+1)*(ir+1))*dr; */
  	r = (ir + 0.5)*dr;
  	shellvolume = 4.0*PI*r*r*dr; /* per spherical shell */
    Fsph = Csph[ir]/Nphotons/shellvolume/mua;
  	shellvolume = 2.0*PI*r*dr;   /* per cm length of cylinder */
    Fcyl = Ccyl[ir]/Nphotons/shellvolume/mua;
  	shellvolume = dr;            /* per cm2 area of plane */
    Fpla =Cpla[ir]/Nphotons/shellvolume/mua;
  	fprintf(target, "%5.5f \t %4.3e \t %4.3e \t %4.3e \n", r, Fsph, Fcyl, Fpla);
  	}

// Flush the buffer to ensure all data is written
fflush(target);

fclose(target);


double bins_per_1_cm = NR_z/z_size;
save_3d_array_to_json("mc456_mc_cube.json", Cube, NR_xy, NR_xy, NR_z, Nphotons, cube_overflow, bins_per_1_cm);

} /* end of main */

 

/* SUBROUTINES */

/**************************************************************************
 *	RandomGen
 *      A random number generator that generates uniformly
 *      distributed random numbers between 0 and 1 inclusive.
 *      The algorithm is based on:
 *      W.H. Press, S.A. Teukolsky, W.T. Vetterling, and B.P.
 *      Flannery, "Numerical Recipes in C," Cambridge University
 *      Press, 2nd edition, (1992).
 *      and
 *      D.E. Knuth, "Seminumerical Algorithms," 2nd edition, vol. 2
 *      of "The Art of Computer Programming", Addison-Wesley, (1981).
 *
 *      When Type is 0, sets Seed as the seed. Make sure 0<Seed<32000.
 *      When Type is 1, returns a random number.
 *      When Type is 2, gets the status of the generator.
 *      When Type is 3, restores the status of the generator.
 *
 *      The status of the generator is represented by Status[0..56].
 *
 *      Make sure you initialize the seed before you get random
 *      numbers.
 ****/
#define MBIG 1000000000
#define MSEED 161803398
#define MZ 0
#define FAC 1.0E-9

double RandomGen(char Type, long Seed, long *Status){
  static long i1, i2, ma[56];   /* ma[0] is not used. */
  long        mj, mk;
  short       i, ii;

  if (Type == 0) {              /* set seed. */
    mj = MSEED - (Seed < 0 ? -Seed : Seed);
    mj %= MBIG;
    ma[55] = mj;
    mk = 1;
    for (i = 1; i <= 54; i++) {
      ii = (21 * i) % 55;
      ma[ii] = mk;
      mk = mj - mk;
      if (mk < MZ)
        mk += MBIG;
      mj = ma[ii];
    }
    for (ii = 1; ii <= 4; ii++)
      for (i = 1; i <= 55; i++) {
        ma[i] -= ma[1 + (i + 30) % 55];
        if (ma[i] < MZ)
          ma[i] += MBIG;
      }
    i1 = 0;
    i2 = 31;
  } else if (Type == 1) {       /* get a number. */
    if (++i1 == 56)
      i1 = 1;
    if (++i2 == 56)
      i2 = 1;
    mj = ma[i1] - ma[i2];
    if (mj < MZ)
      mj += MBIG;
    ma[i1] = mj;
    return (mj * FAC);
  } else if (Type == 2) {       /* get status. */
    for (i = 0; i < 55; i++)
      Status[i] = ma[i + 1];
    Status[55] = i1;
    Status[56] = i2;
  } else if (Type == 3) {       /* restore status. */
    for (i = 0; i < 55; i++)
      ma[i + 1] = Status[i];
    i1 = Status[55];
    i2 = Status[56];
  } else
    puts("Wrong parameter to RandomGen().");
  return (0);
}
#undef MBIG
#undef MSEED
#undef MZ
#undef FAC



void save_3d_array_to_json(const char* filename, double arr[180][180][240], int x, int y, int z, long long Nphotons, double cube_overflow, double bins_per_1_cm) {
    FILE *file = fopen(filename, "w");
    if (file == NULL) {
        printf("Error opening file!\n");
        return;
    }

    /*
    data = {
    "n_photons": Nphotons,
    "overflow": cube_overflow,
    "cube": Cube
    }
    */

    fprintf(file, "{\n");
    fprintf(file, "\"n_photons\": %lld,\n", Nphotons);
    fprintf(file, "\"overflow\": %4.3e,\n", cube_overflow);
    fprintf(file, "\"bins_per_1_cm\": %4.3e,\n",  bins_per_1_cm);

    // Start the JSON array
    fprintf(file, "\"cube\": [\n");

    // Iterate through the 3D array
    for (int i = 0; i < x; i++) {
        fprintf(file, "  [\n");  // Start of the 2D array
        for (int j = 0; j < y; j++) {
            fprintf(file, "    [");  // Start of the 1D array
            for (int k = 0; k < z; k++) {
                fprintf(file, "%4.3e", arr[i][j][k]);
                if (k < z - 1) {
                    fprintf(file, ", ");
                }
            }
            fprintf(file, "]");  // End of the 1D array
            if (j < y - 1) {
                fprintf(file, ",\n");
            } else {
                fprintf(file, "\n");
            }
        }
        fprintf(file, "  ]");  // End of the 2D array
        if (i < x - 1) {
            fprintf(file, ",\n");
        } else {
            fprintf(file, "\n");
        }
    }

    // End the JSON array
    fprintf(file, "]\n");
    fprintf(file, "}\n");

    // Flush the buffer to ensure all data is written
    fflush(file);
    fclose(file);
}


void displayProgressBar(long long progress, long long total, long long min_step) {
    if (progress % min_step == 0)
    {
      int barWidth = 50; // Width of the progress bar
      int completed = (progress * barWidth) / total;

      printf("[");
      for (int i = 0; i < barWidth; i++) {
          if (i < completed) {
              printf("#");
          } else {
              printf(" ");
          }
      }
      printf("] %lld%%", (progress * 100) / total);
      if (progress != total) printf("\r");
      else printf("\n");
      fflush(stdout);  // Force the output to be printed immediately
    }
}


free(Cube);