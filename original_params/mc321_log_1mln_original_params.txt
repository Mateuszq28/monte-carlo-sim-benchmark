time elapsed: 0.5768 seconds

=================================

sim results:

number of photons = 1000000.000000
bin size = 0.03000 [cm] 
last row is overflow. Ignore.
r [cm] 	 Fsph [1/cm2] 	 Fcyl [1/cm2] 	 Fpla [1/cm2]
0.01500 	 3.499e+02 	 1.597e+01 	 3.936e+00 
0.04500 	 3.768e+01 	 4.893e+00 	 2.598e+00 
0.07500 	 1.317e+01 	 2.736e+00 	 2.099e+00 
0.10500 	 6.517e+00 	 1.860e+00 	 1.785e+00 
0.13500 	 3.835e+00 	 1.363e+00 	 1.562e+00 
0.16500 	 2.492e+00 	 1.048e+00 	 1.392e+00 
0.19500 	 1.709e+00 	 8.303e-01 	 1.241e+00 
0.22500 	 1.251e+00 	 6.931e-01 	 1.130e+00 
0.25500 	 9.497e-01 	 5.839e-01 	 1.040e+00 
0.28500 	 7.314e-01 	 4.988e-01 	 9.367e-01 
0.31500 	 5.877e-01 	 4.283e-01 	 8.705e-01 
0.34500 	 4.720e-01 	 3.722e-01 	 8.082e-01 
0.37500 	 3.901e-01 	 3.259e-01 	 7.454e-01 
0.40500 	 3.256e-01 	 2.906e-01 	 6.920e-01 
0.43500 	 2.687e-01 	 2.581e-01 	 6.393e-01 
0.46500 	 2.307e-01 	 2.327e-01 	 6.049e-01 
0.49500 	 2.003e-01 	 2.100e-01 	 5.664e-01 
0.52500 	 1.704e-01 	 1.872e-01 	 5.262e-01 
0.55500 	 1.476e-01 	 1.721e-01 	 4.991e-01 
0.58500 	 1.308e-01 	 1.560e-01 	 4.725e-01 
0.61500 	 1.142e-01 	 1.407e-01 	 4.356e-01 
0.64500 	 1.003e-01 	 1.295e-01 	 4.105e-01 
0.67500 	 8.852e-02 	 1.179e-01 	 3.915e-01 
0.70500 	 7.892e-02 	 1.094e-01 	 3.731e-01 
0.73500 	 7.027e-02 	 1.000e-01 	 3.488e-01 
0.76500 	 6.258e-02 	 9.361e-02 	 3.311e-01 
0.79500 	 5.719e-02 	 8.515e-02 	 3.138e-01 
0.82500 	 5.093e-02 	 7.910e-02 	 2.959e-01 
0.85500 	 4.632e-02 	 7.370e-02 	 2.798e-01 
0.88500 	 4.185e-02 	 7.003e-02 	 2.685e-01 
0.91500 	 3.810e-02 	 6.385e-02 	 2.542e-01 
0.94500 	 3.456e-02 	 5.996e-02 	 2.412e-01 
0.97500 	 3.111e-02 	 5.545e-02 	 2.262e-01 
1.00500 	 2.879e-02 	 5.106e-02 	 2.207e-01 
1.03500 	 2.662e-02 	 4.874e-02 	 2.068e-01 
1.06500 	 2.423e-02 	 4.500e-02 	 1.944e-01 
1.09500 	 2.261e-02 	 4.202e-02 	 1.856e-01 
1.12500 	 2.041e-02 	 3.897e-02 	 1.790e-01 
1.15500 	 1.847e-02 	 3.716e-02 	 1.695e-01 
1.18500 	 1.743e-02 	 3.528e-02 	 1.644e-01 
1.21500 	 1.589e-02 	 3.328e-02 	 1.545e-01 
1.24500 	 1.517e-02 	 3.096e-02 	 1.477e-01 
1.27500 	 1.384e-02 	 2.938e-02 	 1.409e-01 
1.30500 	 1.256e-02 	 2.595e-02 	 1.338e-01 
1.33500 	 1.171e-02 	 2.572e-02 	 1.280e-01 
1.36500 	 1.087e-02 	 2.359e-02 	 1.249e-01 
1.39500 	 1.006e-02 	 2.235e-02 	 1.176e-01 
1.42500 	 9.250e-03 	 2.155e-02 	 1.123e-01 
1.45500 	 8.629e-03 	 2.071e-02 	 1.102e-01 
1.48500 	 8.231e-03 	 1.937e-02 	 1.020e-01 
1.51500 	 7.535e-03 	 1.851e-02 	 9.693e-02 
1.54500 	 7.095e-03 	 1.728e-02 	 9.737e-02 
1.57500 	 6.789e-03 	 1.628e-02 	 8.810e-02 
1.60500 	 6.225e-03 	 1.531e-02 	 8.833e-02 
1.63500 	 5.803e-03 	 1.467e-02 	 8.180e-02 
1.66500 	 5.454e-03 	 1.362e-02 	 7.583e-02 
1.69500 	 5.125e-03 	 1.325e-02 	 7.590e-02 
1.72500 	 4.709e-03 	 1.252e-02 	 6.980e-02 
1.75500 	 4.484e-03 	 1.180e-02 	 7.033e-02 
1.78500 	 4.152e-03 	 1.123e-02 	 6.280e-02 
1.81500 	 3.986e-03 	 1.064e-02 	 6.263e-02 
1.84500 	 3.805e-03 	 1.027e-02 	 6.127e-02 
1.87500 	 3.525e-03 	 9.479e-03 	 5.837e-02 
1.90500 	 3.299e-03 	 9.371e-03 	 5.703e-02 
1.93500 	 3.113e-03 	 8.710e-03 	 5.260e-02 
1.96500 	 2.937e-03 	 8.275e-03 	 5.150e-02 
1.99500 	 2.702e-03 	 7.980e-03 	 4.937e-02 
2.02500 	 2.582e-03 	 7.202e-03 	 4.607e-02 
2.05500 	 2.438e-03 	 7.081e-03 	 4.517e-02 
2.08500 	 2.266e-03 	 6.664e-03 	 4.290e-02 
2.11500 	 2.191e-03 	 6.459e-03 	 3.970e-02 
2.14500 	 1.945e-03 	 5.988e-03 	 4.083e-02 
2.17500 	 1.892e-03 	 5.727e-03 	 3.913e-02 
2.20500 	 1.813e-03 	 5.341e-03 	 3.680e-02 
2.23500 	 1.684e-03 	 5.208e-03 	 3.607e-02 
2.26500 	 1.583e-03 	 5.022e-03 	 3.450e-02 
2.29500 	 1.549e-03 	 4.797e-03 	 3.303e-02 
2.32500 	 1.466e-03 	 4.465e-03 	 3.043e-02 
2.35500 	 1.387e-03 	 4.359e-03 	 3.067e-02 
2.38500 	 1.261e-03 	 4.017e-03 	 2.977e-02 
2.41500 	 1.236e-03 	 3.906e-03 	 2.767e-02 
2.44500 	 1.143e-03 	 3.624e-03 	 2.733e-02 
2.47500 	 1.064e-03 	 3.537e-03 	 2.583e-02 
2.50500 	 9.968e-04 	 3.431e-03 	 2.427e-02 
2.53500 	 9.721e-04 	 3.250e-03 	 2.363e-02 
2.56500 	 9.027e-04 	 3.233e-03 	 2.080e-02 
2.59500 	 8.441e-04 	 2.895e-03 	 2.077e-02 
2.62500 	 8.596e-04 	 2.908e-03 	 2.147e-02 
2.65500 	 7.808e-04 	 2.799e-03 	 2.080e-02 
2.68500 	 7.528e-04 	 2.565e-03 	 2.110e-02 
2.71500 	 7.219e-04 	 2.538e-03 	 1.940e-02 
2.74500 	 6.646e-04 	 2.308e-03 	 1.890e-02 
2.77500 	 6.462e-04 	 2.214e-03 	 1.703e-02 
2.80500 	 6.011e-04 	 2.152e-03 	 1.663e-02 
2.83500 	 5.875e-04 	 2.042e-03 	 1.627e-02 
2.86500 	 5.413e-04 	 1.931e-03 	 1.567e-02 
2.89500 	 5.210e-04 	 1.838e-03 	 1.523e-02 
2.92500 	 4.914e-04 	 1.881e-03 	 1.530e-02 
2.95500 	 4.596e-04 	 1.679e-03 	 1.413e-02 
2.98500 	 4.457e-04 	 1.662e-03 	 1.300e-02 
3.01500 	 1.454e-02 	 4.944e-02 	 3.471e-01 


=================================

code that generated this simulation:


/********************************************
 *  mc321.c    , in ANSI Standard C programing language
 *
 *  Monte Carlo simulation yielding spherical, cylindrical, and planar 
 *    responses to an isotropic point source in an infinite homogeneous 
 *    medium with no boundaries. This program is a minimal Monte Carlo 
 *    program scoring photon distributions in spherical, cylindrical, 
 *    and planar shells.
 *
 *  by Steven L. Jacques based on prior collaborative work 
 *    with Lihong Wang, Scott Prahl, and Marleen Keijzer.
 *    partially funded by the NIH (R29-HL45045, 1991-1997) and  
 *    the DOE (DE-FG05-91ER617226, DE-FG03-95ER61971, 1991-1999).
 *
 *  A published report illustrates use of the program:
 *    S. L. Jacques: "Light distributions from point, line, and plane 
 *    sources for photochemical reactions and fluorescence in turbid 
 *    biological tissues," Photochem. Photobiol. 67:23-32, 1998. 
 *
 *  Trivial fixes to remove warnings SAP, 11/2017
 **********/

#include <math.h>
#include <stdio.h>

#define	PI          3.1415926
#define	LIGHTSPEED	2.997925E10 /* in vacuo speed of light [cm/s] */
#define ALIVE       1   		/* if photon not yet terminated */
#define DEAD        0    		/* if photon is to be terminated */
#define THRESHOLD   0.01		/* used in roulette */
#define CHANCE      0.1  		/* used in roulette */
#define COS90D      1.0E-6
     /* If cos(theta) <= COS90D, theta >= PI/2 - 1e-6 rad. */
#define ONE_MINUS_COSZERO 1.0E-12
     /* If 1-cos(theta) <= ONE_MINUS_COSZERO, fabs(theta) <= 1e-6 rad. */
     /* If 1+cos(theta) <= ONE_MINUS_COSZERO, fabs(PI-theta) <= 1e-6 rad. */
#define SIGN(x)           ((x)>=0 ? 1:-1)
#define InitRandomGen    (double) RandomGen(0, 1, NULL)
     /* Initializes the seed for the random number generator. */     
#define RandomNum        (double) RandomGen(1, 0, NULL)
     /* Calls for a random number from the randum number generator. */

/* DECLARE FUNCTION */
double RandomGen(char Type, long Seed, long *Status);  
     /* Random number generator */


int main() {

/* Propagation parameters */
double	x, y, z;    /* photon position */
double	ux, uy, uz; /* photon trajectory as cosines */
double  uxx, uyy, uzz;	/* temporary values used during SPIN */
double	s;          /* step sizes. s = -log(RND)/mus [cm] */
double	costheta;   /* cos(theta) */
double  sintheta;   /* sin(theta) */
double	cospsi;     /* cos(psi) */
double  sinpsi;     /* sin(psi) */
double	psi;        /* azimuthal angle */
double	i_photon;   /* current photon */
double	W;          /* photon weight */
double	absorb;     /* weighted deposited in a step due to absorption */
short   photon_status;  /* flag = ALIVE=1 or DEAD=0 */

/* other variables */
double	Csph[101];  /* spherical   photon concentration CC[ir=0..100] */
double	Ccyl[101];  /* cylindrical photon concentration CC[ir=0..100] */
double	Cpla[101];  /* planar      photon concentration CC[ir=0..100] */
double	Fsph;       /* fluence in spherical shell */
double	Fcyl;       /* fluence in cylindrical shell */
double	Fpla;       /* fluence in planar shell */
double	mua;        /* absorption coefficient [cm^-1] */
double	mus;        /* scattering coefficient [cm^-1] */
double	g;          /* anisotropy [-] */
double	albedo;     /* albedo of tissue */
double	nt;         /* tissue index of refraction */
double	Nphotons;   /* number of photons in simulation */
short	NR;         /* number of radial positions */
double	radial_size;  /* maximum radial size */
double	r;          /* radial position */
double  dr;         /* radial bin size */
short	ir;         /* index to radial position */
double  shellvolume;  /* volume of shell at radial position r */

/* dummy variables */
double  rnd;        /* assigned random value 0-1 */
double	temp;    /* dummy variables */
FILE*	target;     /* point to output file */


/**** INPUT
   Input the optical properties
   Input the bin and array sizes 
   Input the number of photons
*****/

mua         = 1.0;     /* cm^-1 */
mus         = 0.0;  /* cm^-1 */
g           = 0.90;  
nt          = 1.33;
Nphotons    = 1e6; /* set number of photons in simulation */
radial_size = 3.0;   /* cm, total range over which bins extend */
NR          = 100;	 /* set number of bins.  */
   /* IF NR IS ALTERED, THEN USER MUST ALSO ALTER THE ARRAY DECLARATION TO A SIZE = NR + 1. */
dr          = radial_size/NR;  /* cm */
albedo      = mus/(mus + mua);


/**** INITIALIZATIONS 
*****/
i_photon = 0;
InitRandomGen;
for (ir=0; ir<=NR; ir++) {
   Csph[ir] = 0;
   Ccyl[ir] = 0;
   Cpla[ir] = 0;
   }
   
/**** RUN
   Launch N photons, initializing each one before progation.
*****/
do {


/**** LAUNCH 
   Initialize photon position and trajectory.
   Implements an isotropic point source.
*****/
i_photon += 1;	/* increment photon count */
W = 1.0;                    /* set photon weight to one */
photon_status = ALIVE;      /* Launch an ALIVE photon */

x = 0;                      /* Set photon position to origin. */
y = 0;
z = 0;

/* Randomly set photon trajectory to yield an isotropic source. */
costheta = 2.0*RandomNum - 1.0;   
sintheta = sqrt(1.0 - costheta*costheta);	/* sintheta is always positive */
psi = 2.0*PI*RandomNum;
ux = sintheta*cos(psi);
uy = sintheta*sin(psi);
uz = costheta;


/* HOP_DROP_SPIN_CHECK
   Propagate one photon until it dies as determined by ROULETTE.
*******/
do {


/**** HOP
   Take step to new position
   s = stepsize
   ux, uy, uz are cosines of current photon trajectory
*****/
  while ((rnd = RandomNum) <= 0.0);   /* yields 0 < rnd <= 1 */
  s = -log(rnd)/(mua + mus);          /* Step size.  Note: log() is base e */
  x += s * ux;                        /* Update positions. */
  y += s * uy;
  z += s * uz;


/**** DROP
   Drop photon weight (W) into local bin.
*****/
   absorb = W*(1 - albedo);      /* photon weight absorbed at this step */
   W -= absorb;                  /* decrement WEIGHT by amount absorbed */
   
   /* spherical */
   r = sqrt(x*x + y*y + z*z);    /* current spherical radial position */
   ir = (short)(r/dr);           /* ir = index to spatial bin */
   if (ir >= NR) ir = NR;        /* last bin is for overflow */
   Csph[ir] += absorb;           /* DROP absorbed weight into bin */
   
   /* cylindrical */
   r = sqrt(x*x + y*y);          /* current cylindrical radial position */
   ir = (short)(r/dr);           /* ir = index to spatial bin */
   if (ir >= NR) ir = NR;        /* last bin is for overflow */
   Ccyl[ir] += absorb;           /* DROP absorbed weight into bin */
   
   /* planar */
   r = fabs(z);                  /* current planar radial position */
   ir = (short)(r/dr);           /* ir = index to spatial bin */
   if (ir >= NR) ir = NR;        /* last bin is for overflow */
   Cpla[ir] += absorb;           /* DROP absorbed weight into bin */
   

/**** SPIN 
   Scatter photon into new trajectory defined by theta and psi.
   Theta is specified by cos(theta), which is determined 
   based on the Henyey-Greenstein scattering function.
   Convert theta and psi into cosines ux, uy, uz. 
*****/
  /* Sample for costheta */
  rnd = RandomNum;
     if (g == 0.0)
        costheta = 2.0*rnd - 1.0;
     else {
        double temp = (1.0 - g*g)/(1.0 - g + 2*g*rnd);
        costheta = (1.0 + g*g - temp*temp)/(2.0*g);
        }
  sintheta = sqrt(1.0 - costheta*costheta); /* sqrt() is faster than sin(). */

  /* Sample psi. */
  psi = 2.0*PI*RandomNum;
  cospsi = cos(psi);
  if (psi < PI)
    sinpsi = sqrt(1.0 - cospsi*cospsi);     /* sqrt() is faster than sin(). */
  else
    sinpsi = -sqrt(1.0 - cospsi*cospsi);

  /* New trajectory. */
  if (1 - fabs(uz) <= ONE_MINUS_COSZERO) {      /* close to perpendicular. */
    uxx = sintheta * cospsi;
    uyy = sintheta * sinpsi;
    uzz = costheta * SIGN(uz);   /* SIGN() is faster than division. */
    } 
  else {					/* usually use this option */
    temp = sqrt(1.0 - uz * uz);
    uxx = sintheta * (ux * uz * cospsi - uy * sinpsi) / temp + ux * costheta;
    uyy = sintheta * (uy * uz * cospsi + ux * sinpsi) / temp + uy * costheta;
    uzz = -sintheta * cospsi * temp + uz * costheta;
    }
    
  /* Update trajectory */
  ux = uxx;
  uy = uyy;
  uz = uzz;


/**** CHECK ROULETTE 
   If photon weight below THRESHOLD, then terminate photon using Roulette technique.
   Photon has CHANCE probability of having its weight increased by factor of 1/CHANCE,
   and 1-CHANCE probability of terminating.
*****/
if (W < THRESHOLD) {
   if (RandomNum <= CHANCE)
      W /= CHANCE;
   else photon_status = DEAD;
   }


} /* end STEP_CHECK_HOP_SPIN */
while (photon_status == ALIVE);

  /* If photon dead, then launch new photon. */
} /* end RUN */
while (i_photon < Nphotons);


/**** SAVE
   Convert data to relative fluence rate [cm^-2] and save to file called "mcmin321.out".
*****/
// target = fopen("mc321.out", "w");
target = fopen("mc321_out.txt", "w");

/* print header */
fprintf(target, "number of photons = %f\n", Nphotons);
fprintf(target, "bin size = %5.5f [cm] \n", dr);
fprintf(target, "last row is overflow. Ignore.\n");

/* print column titles */
fprintf(target, "r [cm] \t Fsph [1/cm2] \t Fcyl [1/cm2] \t Fpla [1/cm2]\n");

/* print data:  radial position, fluence rates for 3D, 2D, 1D geometries */
for (ir=0; ir<=NR; ir++) {
  	/* r = sqrt(1.0/3 - (ir+1) + (ir+1)*(ir+1))*dr; */
  	r = (ir + 0.5)*dr;
  	shellvolume = 4.0*PI*r*r*dr; /* per spherical shell */
    Fsph = Csph[ir]/Nphotons/shellvolume/mua;
  	shellvolume = 2.0*PI*r*dr;   /* per cm length of cylinder */
    Fcyl = Ccyl[ir]/Nphotons/shellvolume/mua;
  	shellvolume = dr;            /* per cm2 area of plane */
    Fpla =Cpla[ir]/Nphotons/shellvolume/mua;
  	fprintf(target, "%5.5f \t %4.3e \t %4.3e \t %4.3e \n", r, Fsph, Fcyl, Fpla);
  	}

fclose(target);


} /* end of main */

 

/* SUBROUTINES */

/**************************************************************************
 *	RandomGen
 *      A random number generator that generates uniformly
 *      distributed random numbers between 0 and 1 inclusive.
 *      The algorithm is based on:
 *      W.H. Press, S.A. Teukolsky, W.T. Vetterling, and B.P.
 *      Flannery, "Numerical Recipes in C," Cambridge University
 *      Press, 2nd edition, (1992).
 *      and
 *      D.E. Knuth, "Seminumerical Algorithms," 2nd edition, vol. 2
 *      of "The Art of Computer Programming", Addison-Wesley, (1981).
 *
 *      When Type is 0, sets Seed as the seed. Make sure 0<Seed<32000.
 *      When Type is 1, returns a random number.
 *      When Type is 2, gets the status of the generator.
 *      When Type is 3, restores the status of the generator.
 *
 *      The status of the generator is represented by Status[0..56].
 *
 *      Make sure you initialize the seed before you get random
 *      numbers.
 ****/
#define MBIG 1000000000
#define MSEED 161803398
#define MZ 0
#define FAC 1.0E-9

double RandomGen(char Type, long Seed, long *Status){
  static long i1, i2, ma[56];   /* ma[0] is not used. */
  long        mj, mk;
  short       i, ii;

  if (Type == 0) {              /* set seed. */
    mj = MSEED - (Seed < 0 ? -Seed : Seed);
    mj %= MBIG;
    ma[55] = mj;
    mk = 1;
    for (i = 1; i <= 54; i++) {
      ii = (21 * i) % 55;
      ma[ii] = mk;
      mk = mj - mk;
      if (mk < MZ)
        mk += MBIG;
      mj = ma[ii];
    }
    for (ii = 1; ii <= 4; ii++)
      for (i = 1; i <= 55; i++) {
        ma[i] -= ma[1 + (i + 30) % 55];
        if (ma[i] < MZ)
          ma[i] += MBIG;
      }
    i1 = 0;
    i2 = 31;
  } else if (Type == 1) {       /* get a number. */
    if (++i1 == 56)
      i1 = 1;
    if (++i2 == 56)
      i2 = 1;
    mj = ma[i1] - ma[i2];
    if (mj < MZ)
      mj += MBIG;
    ma[i1] = mj;
    return (mj * FAC);
  } else if (Type == 2) {       /* get status. */
    for (i = 0; i < 55; i++)
      Status[i] = ma[i + 1];
    Status[55] = i1;
    Status[56] = i2;
  } else if (Type == 3) {       /* restore status. */
    for (i = 0; i < 55; i++)
      ma[i + 1] = Status[i];
    i1 = Status[55];
    i2 = Status[56];
  } else
    puts("Wrong parameter to RandomGen().");
  return (0);
}
#undef MBIG
#undef MSEED
#undef MZ
#undef FAC

